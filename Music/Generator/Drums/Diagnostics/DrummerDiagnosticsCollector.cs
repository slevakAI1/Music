// AI: purpose=Collects drummer decision data during generation and builds DrummerDiagnostics (Story 7.1).
// AI: invariants=Mutable during collection, immutable output; zero-cost when disabled (collector is null).
// AI: deps=DrummerDiagnostics and sub-records; IAgentMemory for memory snapshots; DrumCandidate for candidate data.
// AI: change=Story 7.1 provides opt-in diagnostics collection without changing generation behavior.

using Music.Generator.Core;

namespace Music.Generator.Drums.Diagnostics;

/// <summary>
/// Collects drummer decision data during pipeline execution.
/// Story 7.1: Opt-in diagnostics collection for decision tracing.
/// Usage: Create when diagnostics enabled; null when disabled for zero-cost.
/// </summary>
public sealed class DrummerDiagnosticsCollector
{
    private readonly int _barNumber;
    private readonly string _role;
    private readonly List<OperatorTrace> _operatorsConsidered = [];
    private readonly List<OperatorTrace> _operatorsSelected = [];
    private readonly List<RejectionTrace> _operatorsRejected = [];
    private readonly List<PhysicalityViolation> _physicalityViolations = [];

    private MemoryStateSnapshot? _memoryState;
    private DensityComparison? _densityComparison;

    /// <summary>
    /// Creates a new diagnostics collector for a specific bar and role.
    /// </summary>
    /// <param name="barNumber">Bar number (1-based).</param>
    /// <param name="role">Role name (e.g., "Kick", "Snare").</param>
    public DrummerDiagnosticsCollector(int barNumber, string role)
    {
        _barNumber = barNumber;
        _role = role;
    }

    /// <summary>
    /// Records an operator that was considered by the pipeline.
    /// </summary>
    /// <param name="operatorId">Unique operator identifier.</param>
    /// <param name="operatorFamily">Operator family classification.</param>
    /// <param name="candidateCount">Number of candidates generated.</param>
    public void RecordOperatorConsidered(string operatorId, string operatorFamily, int candidateCount)
    {
        _operatorsConsidered.Add(new OperatorTrace
        {
            OperatorId = operatorId,
            OperatorFamily = operatorFamily,
            CandidateCount = candidateCount
        });
    }

    /// <summary>
    /// Records an operator selection with scoring details.
    /// </summary>
    /// <param name="operatorId">Unique operator identifier.</param>
    /// <param name="operatorFamily">Operator family classification.</param>
    /// <param name="candidateCount">Total candidates generated by operator.</param>
    /// <param name="selectedCount">Number of candidates selected.</param>
    /// <param name="baseScore">Base score from operator.</param>
    /// <param name="styleWeight">Style weight multiplier.</param>
    /// <param name="memoryPenalty">Memory penalty multiplier (1.0 - repetition penalty).</param>
    /// <param name="finalScore">Final score after all multipliers.</param>
    public void RecordOperatorSelected(
        string operatorId,
        string operatorFamily,
        int candidateCount,
        int selectedCount,
        double baseScore,
        double styleWeight,
        double memoryPenalty,
        double finalScore)
    {
        _operatorsSelected.Add(new OperatorTrace
        {
            OperatorId = operatorId,
            OperatorFamily = operatorFamily,
            CandidateCount = candidateCount,
            SelectedCount = selectedCount,
            BaseScore = baseScore,
            StyleWeight = styleWeight,
            MemoryPenalty = memoryPenalty,
            FinalScore = finalScore
        });
    }

    /// <summary>
    /// Records rejection of an operator or candidate.
    /// </summary>
    /// <param name="reason">Hierarchical rejection reason (e.g., "PhysicalityFilter:LimbConflict:RightHand").</param>
    /// <param name="operatorId">Operator ID (if operator-level rejection).</param>
    /// <param name="candidateId">Candidate ID (if candidate-level rejection).</param>
    /// <param name="detail">Additional context or detail.</param>
    public void RecordRejection(string reason, string? operatorId = null, string? candidateId = null, string? detail = null)
    {
        _operatorsRejected.Add(new RejectionTrace
        {
            OperatorId = operatorId,
            CandidateId = candidateId,
            Reason = reason,
            Detail = detail
        });
    }

    /// <summary>
    /// Records a physicality violation that caused candidate filtering.
    /// </summary>
    /// <param name="candidateId">Candidate ID that was rejected.</param>
    /// <param name="violationType">Type of violation (e.g., "LimbConflict", "StickingViolation", "Overcrowding").</param>
    /// <param name="reason">Detailed reason with hierarchical format.</param>
    /// <param name="wasProtected">Whether candidate was protected.</param>
    public void RecordPhysicalityViolation(
        string candidateId,
        string violationType,
        string reason,
        bool wasProtected = false)
    {
        _physicalityViolations.Add(new PhysicalityViolation
        {
            CandidateId = candidateId,
            ViolationType = violationType,
            Reason = reason,
            WasProtected = wasProtected
        });
    }

    /// <summary>
    /// Records memory state snapshot from agent memory.
    /// </summary>
    /// <param name="memory">Agent memory instance to snapshot.</param>
    /// <param name="memoryWindowSize">Window size to use for snapshot (default 8).</param>
    public void RecordMemoryState(IGeneratorMemory? memory, int memoryWindowSize = 8)
    {
        if (memory == null)
        {
            _memoryState = new MemoryStateSnapshot
            {
                RecentOperatorUsage = new Dictionary<string, int>(),
                LastFillShape = null,
                MemoryWindowSize = 0
            };
            return;
        }

        // Get recent operator usage from memory
        var recentUsage = memory.GetRecentOperatorUsage(memoryWindowSize);

        // Get last fill shape if available
        FillShapeSnapshot? fillSnapshot = null;
        var lastFill = memory.GetLastFillShape();
        if (lastFill != null)
        {
            fillSnapshot = new FillShapeSnapshot
            {
                BarNumber = lastFill.BarPosition,
                Roles = lastFill.RolesInvolved,
                Density = lastFill.DensityLevel,
                EndingBeat = lastFill.DurationBars
            };
        }

        _memoryState = new MemoryStateSnapshot
        {
            RecentOperatorUsage = recentUsage,
            LastFillShape = fillSnapshot,
            MemoryWindowSize = memoryWindowSize
        };
    }

    /// <summary>
    /// Records density target vs actual comparison.
    /// </summary>
    /// <param name="targetDensity">Target density (0.0-1.0) from policy.</param>
    /// <param name="actualDensity">Actual density achieved.</param>
    /// <param name="targetEventCount">Target event count (optional).</param>
    /// <param name="actualEventCount">Actual event count.</param>
    public void RecordDensityComparison(
        double targetDensity,
        double actualDensity,
        int? targetEventCount,
        int actualEventCount)
    {
        _densityComparison = new DensityComparison
        {
            TargetDensity = targetDensity,
            ActualDensity = actualDensity,
            TargetEventCount = targetEventCount,
            ActualEventCount = actualEventCount
        };
    }

    /// <summary>
    /// Builds the immutable DrummerDiagnostics record from collected data.
    /// Call after all pipeline stages have recorded their data.
    /// </summary>
    /// <returns>Immutable diagnostics record.</returns>
    public DrummerDiagnostics Build()
    {
        return new DrummerDiagnostics
        {
            BarNumber = _barNumber,
            Role = _role,
            OperatorsConsidered = _operatorsConsidered.ToList(),
            OperatorsSelected = _operatorsSelected.ToList(),
            OperatorsRejected = _operatorsRejected.ToList(),
            MemoryState = _memoryState ?? new MemoryStateSnapshot
            {
                RecentOperatorUsage = new Dictionary<string, int>(),
                LastFillShape = null,
                MemoryWindowSize = 0
            },
            DensityTargetVsActual = _densityComparison ?? new DensityComparison
            {
                TargetDensity = 0.0,
                ActualDensity = 0.0,
                TargetEventCount = null,
                ActualEventCount = 0
            },
            PhysicalityViolationsFiltered = _physicalityViolations.ToList()
        };
    }
}
