# Drum fill generation: high-quality + creative (with your inputs)

You’re in a strong position now that you have:
- **(1) Groove onset grids** for kick/snare/hat (K/S/H)
- **(2) A limb/feasibility constraint system**

That means you can build a fill generator that’s *musical*, *creative*, and *never unplayable*, without needing a huge MIDI library.

Below is a practical architecture that consistently produces “record-ready” fills.

---

## The best approach: Hybrid generator + repair + ranker

Think of fills as **candidates** generated by 1–2 engines, then **repaired**, then **ranked**.  
This avoids the two classic failures:
- Pure rules = stiff / predictable
- Pure ML/random = messy / doesn’t land

### High-level pipeline
1. **Decide fill placement + length**
2. **Choose fill intent/type** (based on section + energy + history)
3. **Generate many candidates** (template-variation and/or ML)
4. **Repair** (fix overlaps, impossible clusters, missing resolution)
5. **Orchestrate** (map strokes to kit sensibly)
6. **Dynamics curve** (velocity + density ramps)
7. **Feasibility filter** (your limb constraint system)
8. **Score + pick** (fit, resolution, novelty, energy)

---

## 1) Decide *whether* to fill + choose length

Use your context inputs:
- section type (verse/chorus/bridge/etc.)
- energy level + delta
- time since last fill + previous fill types

Recommended lengths:
- **1/4 bar**: subtle pickup
- **1/2 bar**: common
- **1 bar**: standard fill
- **2 bars**: transitions / breakdowns

Rule of thumb:
- Higher energy *or* section boundary ⇒ increase fill probability and length.
- If last fill was recent ⇒ shorten or skip.

---

## 2) Choose fill “intent” (type)

Pick an intent before generating notes. Examples:
- **Pickup** (snare lead-in, minimal toms)
- **Tom run** (high→mid→floor)
- **Snare roll / buzz-like texture**
- **Linear fill** (no simultaneous hits; clean + modern)
- **Half-time triplet fill**
- **Cymbal swell / crash setup**

Condition this on:
- section (chorus wants bigger landing than verse)
- energy target
- groove density (busy groove → simpler fill)

---

## 3) Candidate generators that work with your K/S/H onset grids

You don’t need a huge library. A small set of archetypes + variation is enough.

### A) Groove-preserving “transform” generator (very effective)
Take your last 1–2 bars of groove and transform them into fill candidates:
- Keep **some kick anchors** from the groove (helps “belonging”)
- Increase density or subdivision near the end
- Swap some hat events into snare/tom strokes
- Add a short pickup phrase in the last 1/8–1/4 bar

This produces fills that feel like the same drummer, same song.

### B) Template + variation generator (best ROI)
Maintain ~20–50 archetypes (can be hand-made or scraped and cleaned).
Then apply controlled variation:
- **Subdivision**: 8ths → 16ths, or 16ths → triplet bursts
- **Orchestration**: move strokes across toms; swap rim/center; add ghost notes
- **Density ramp**: sparse start → busier end
- **Motif**: repeat a 2–4 hit shape (e.g., S–T–T) with shifting accents

### C) Optional: pretrained ML for “idea candidates”
Use ML as an *idea machine*, not the final authority.
Generate candidates → then repair + feasibility + rank.

---

## 4) Repair step (this is where quality is won)

You asked specifically about:
- fixing overlaps / impossible clusters / missing resolution
- mapping to kit
- dynamics curve

Here’s a concrete repair module you can implement.

### 4.1 Fix overlaps & impossible clusters (musical + mechanical)
Even before limb constraints, do a musical cleanup pass.

**A. Onset collision resolution**
If multiple hits occur at the same tick:
- Prefer **kick+crash** or **snare+kick** on strong beats
- Avoid triple-stacks unless stylistically required
- If two similar voices collide (e.g., snare + snare alt), keep the one with higher priority

Suggested priority by beat strength:
- Downbeat landing: crash/ride + kick (and sometimes snare)
- Backbeat: snare
- Fills: toms/snare, but keep kick anchors if groove needs it

**B. Density limiting (anti-machine-gun)**
Cap per-voice rates:
- Snare roll: allow fast, but require velocity shaping (below)
- Toms: avoid constant 32nds unless genre demands it
- Cymbals: avoid repeated crashes too close together

**C. Grid sanity**
- Quantize to your intended resolution (e.g., 16th/triplet grid)
- If you allow microtiming, apply it *after* repair + scoring

### 4.2 Missing resolution (make the fill land)
A fill that doesn’t “land” sounds amateur.

Add/ensure:
- A clear landing event on **next bar beat 1**:
  - crash/ride + kick (common)
  - or snare flam into crash (style-dependent)
- Reduce complexity in the last 1–2 ticks before downbeat (tiny breath helps)

### 4.3 Voice-leading / contour (why humans like tom runs)
If the fill uses toms, enforce a contour:
- common: **high → mid → floor**
- occasional: **floor → high** (for surprise, use sparingly)
- avoid random tom hopping unless you explicitly want “chaotic”

---

## 5) Map to kit (orchestration rules)

You can generate fills in an abstract “stroke stream” then map it to drums.

### Practical mapping rules
- If intensity is rising, move:
  - snare → high tom → mid tom → floor tom
- Put **accents** on lower toms near the end for weight
- Use ghost notes on snare sparingly early in the fill
- Keep hat out of the way during tom-heavy fills unless it’s a stylistic constant (e.g., metal pedal hat feel)

### Keep groove identity
Because you have K/S/H onset grids, keep *some* of these:
- Preserve kick pattern on strong beats
- Preserve backbeat snare if fill is short (pickup style)
- Or preserve hat pulse early then drop it for the final flourish

This is the “it belongs to the track” trick.

---

## 6) Apply a dynamics curve (velocity + density shaping)

Bad fills are often not “wrong notes”—they’re **flat dynamics**.

### Velocity ramp (simple and effective)
For fill duration `t in [0..1]`:
- Base velocity increases with t (crescendo)
- Accents placed on:
  - beat subdivisions (e.g., 1e&a accents)
  - phrase ends
- Ghost notes:
  - 30–60% of main snare velocity (genre dependent)
- Rolls:
  - start softer, end louder, avoid equal hits

### Density ramp
Let density rise toward the downbeat:
- early: fewer strokes / more space
- late: more strokes / tighter subdivisions
- final hit: strong accent + landing

---

## 7) Your limb constraint system: when to apply it

Apply limb constraints **after repair and orchestration**, but before final selection:
- You want candidates to be musically shaped first
- Then feasibility filters remove the impossible ones

Tip:
- If too many candidates get rejected, feed back:
  - lower density
  - reduce simultaneous hits
  - switch to linear-fill intent

---

## 8) Ranking: pick “best” fill (not just valid)

Generate 8–64 candidates, then score them.

### Suggested scoring components
1. **Fit-to-groove score**
   - Compare accent fingerprint to groove (especially kick anchors)
2. **Resolution score**
   - Strong landing on downbeat
   - Clear phrase ending in the last 1/8 bar
3. **Energy match score**
   - Matches target energy level + section type
4. **Novelty score**
   - Penalize similarity to last N fills (you track previous fills—use it)
5. **Simplicity penalty (optional)**
   - Penalize overly busy fills unless energy is high
6. **Feasibility score**
   - Your limb system can provide a “difficulty” metric; prefer moderate difficulty unless requested

Pick top-1, or sample from top-K (to keep it creative but controlled).

---

## Minimal “no-library” version (still good)
If you truly have no fill library yet, you can still get quality:

1. Generate fills by transforming the groove onset grid:
   - keep kick anchors
   - increase density near the end
   - switch some hat events into tom/snare
2. Orchestrate with tom contour rules
3. Apply dynamics curve
4. Run limb feasibility
5. Rank by fit/resolution/novelty

This already yields fills that sound intentional.

---

## Small library strategy (best quality per effort)
Build **20–50 archetypes**, not thousands:
- 5 pickups
- 10 one-bar tom/snare mixes
- 5 triplet feels
- 5 linear fills
- 5 “big transition” fills
- 5 genre-specific signatures

Then your variation engine + constraints will multiply them into hundreds of distinct fills without sounding like clones.

---

## What I’d do in your situation (direct answer)
- Use your K/S/H onset grids to build a **groove-preserving fill transform engine**
- Add **20–50 archetypes** over time
- Make **repair + orchestration + dynamics** mandatory (that’s “record quality”)
- Let your **limb constraints** be a hard gate
- Use a **ranker** so you choose the best musical candidate, not just the first valid one

---

## If you tell me one thing, I can give you exact rules
If you give:
- target genre (e.g., pop rock vs EDM vs metal)
- typical tempo range
- whether you want “human drummer” realism or “programmed perfection”

…I can propose:
- exact subdivision choices
- velocity ranges and curves
- preferred fill intents per section
- ranking weights that match the genre


Not strictly. If the fill generator’s job is “fit *this* groove,” then the **groove onset grid already carries a lot of genre signal** (density, hat rate, backbeat placement, syncopation). So you *can* build a fill system that only consumes:

- groove onset grids (K/S/H) for the lead-in bars
- section + energy + fill history
- limb/feasibility constraints

…and get good results.

That said, for **consistently high quality across very different styles**, it’s still useful to pass **some style/genre information**, even if it’s indirect.

---

## Why the groove grid isn’t always enough
Different genres can share similar K/S/H onset grids but want different fill behavior:

- **Pop rock vs country**: both can be straight hats + backbeat snare, but fills differ (tom vocabulary, snare pickups, crash usage).
- **EDM vs funk/disco-ish**: similar steady hats, but EDM often wants snare builds; funk wants ghost-note phrasing and kit articulation.
- **Metal vs punk**: both can be dense, but metal tolerates double-kick bursts and faster tom runs; punk often wants simpler, punchier fills.

So: the grid gives rhythm shape, but not always the **fill vocabulary** and **orchestration preferences**.

---

## Practical design: make genre optional, but always use a “style profile”
Best setup: derive a **style profile** from the groove (and optionally blend in genre as a prior).

### Option A (recommended): infer style from the groove (no explicit genre input)
Compute features from the last 1–2 bars of groove:
- subdivision feel (8th vs 16th vs triplet likelihood)
- hat density / continuity
- kick syncopation index
- overall density / sparsity
- swing/shuffle indicator (if you model timing)
- “anchor strength” (kick on strong beats consistency)

Map those features into a **fill policy**:
- allowed subdivisions for fills
- fill length distribution (1/4, 1/2, 1 bar, 2 bars)
- cymbal usage probability (crash/ride frequency)
- tom-run probability + direction preference (high→low vs low→high)
- linear-fill probability (no simultaneous hits)
- max density caps and collision limits
- velocity curve shape (how strongly you crescendo)

This lets the fill generator adapt to whatever groove arrives.

### Option B: include genre as a “prior” (cheap and improves consistency)
If genre is available, use it as a light bias / tie-breaker when the groove is ambiguous:
- allow triplet fills more for shuffle/blues-adjacent styles
- allow snare build rolls more for EDM/pop transitions
- allow double-kick bursts more for metal
- adjust crash/choke probability for rock/metal

Don’t hard-code everything by genre—just nudge probabilities.

---

## What I would implement (best of both)
### Inputs to fill system
- **Required:** groove onset grid (K/S/H lead-in), section, energy, fill history, limb constraints
- **Optional:** genre label (if available)
- **Derived:** style profile computed from groove (+ optional genre prior)

### Decision logic
1. Compute style profile from groove features
2. If genre provided, blend it in as a prior (small weight)
3. Generate fill candidates using the resulting fill policy
4. Repair (resolve collisions, enforce landing) + limb feasibility filter
5. Rank by fit/resolution/novelty and pick top-1 (or sample top-K)

---

## Bottom line
- Simplest system: **No, genre does not have to be an input**—the groove grid + section/energy/history + limb constraints can drive fills.
- Highest reliability across styles: **Yes, keep genre (or an inferred style profile)** because similar grids can imply different fill vocabularies.
