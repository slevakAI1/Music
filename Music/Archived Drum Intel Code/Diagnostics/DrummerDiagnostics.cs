// AI: purpose=Structured diagnostics for drummer agent decision tracing (Story 7.1).
// AI: invariants=Opt-in only; when disabled, diagnostics remain null; captures operator-level decisions.
// AI: deps=DrumCandidate for candidate references; OperatorFamily for classification.
// AI: change=Story 7.1 establishes drummer diagnostics pattern; future stories add serialization/analysis.

namespace Music.Generator.Drums.Diagnostics;

/// <summary>
/// Captures all decision-trace data for a single bar and role during drummer agent generation.
/// Story 7.1: Implement Drummer Diagnostics Collector.
/// When diagnostics disabled, remains null (zero allocations).
/// </summary>
public sealed record DrummerDiagnostics
{
    /// <summary>
    /// Bar number (1-based) this diagnostics applies to.
    /// </summary>
    public required int BarNumber { get; init; }

    /// <summary>
    /// Role name (e.g., "Kick", "Snare") this diagnostics applies to.
    /// </summary>
    public required string Role { get; init; }

    /// <summary>
    /// Operators that were considered by the pipeline.
    /// </summary>
    public required IReadOnlyList<OperatorTrace> OperatorsConsidered { get; init; }

    /// <summary>
    /// Operators whose candidates were selected by the selection engine.
    /// </summary>
    public required IReadOnlyList<OperatorTrace> OperatorsSelected { get; init; }

    /// <summary>
    /// Operators or candidates that were rejected with reasons.
    /// </summary>
    public required IReadOnlyList<RejectionTrace> OperatorsRejected { get; init; }

    /// <summary>
    /// Snapshot of memory state at the time of generation.
    /// </summary>
    public required MemoryStateSnapshot MemoryState { get; init; }

    /// <summary>
    /// Density target vs actual comparison.
    /// </summary>
    public required DensityComparison DensityTargetVsActual { get; init; }

    /// <summary>
    /// Physicality violations that caused candidate filtering.
    /// </summary>
    public required IReadOnlyList<PhysicalityViolation> PhysicalityViolationsFiltered { get; init; }
}

/// <summary>
/// Records operator consideration or selection with scoring details.
/// </summary>
public sealed record OperatorTrace
{
    /// <summary>
    /// Unique operator identifier.
    /// </summary>
    public required string OperatorId { get; init; }

    /// <summary>
    /// Operator family classification.
    /// </summary>
    public required string OperatorFamily { get; init; }

    /// <summary>
    /// Number of candidates generated by this operator.
    /// </summary>
    public required int CandidateCount { get; init; }

    /// <summary>
    /// Base score from operator (before style weight and memory penalty).
    /// </summary>
    public double? BaseScore { get; init; }

    /// <summary>
    /// Style weight multiplier applied.
    /// </summary>
    public double? StyleWeight { get; init; }

    /// <summary>
    /// Memory penalty multiplier (1.0 - repetition penalty).
    /// </summary>
    public double? MemoryPenalty { get; init; }

    /// <summary>
    /// Final score after all multipliers.
    /// </summary>
    public double? FinalScore { get; init; }

    /// <summary>
    /// Number of candidates from this operator that were selected.
    /// </summary>
    public int SelectedCount { get; init; }
}

/// <summary>
/// Records rejection of operator or candidate with hierarchical reason.
/// </summary>
public sealed record RejectionTrace
{
    /// <summary>
    /// Operator ID that was rejected.
    /// </summary>
    public string? OperatorId { get; init; }

    /// <summary>
    /// Candidate ID that was rejected (if specific candidate rejection).
    /// </summary>
    public string? CandidateId { get; init; }

    /// <summary>
    /// Hierarchical rejection reason (e.g., "PhysicalityFilter:LimbConflict:RightHand").
    /// Format: "System:Reason:Detail"
    /// </summary>
    public required string Reason { get; init; }

    /// <summary>
    /// Additional context or detail about rejection.
    /// </summary>
    public string? Detail { get; init; }
}

/// <summary>
/// Snapshot of memory state at time of diagnostics capture.
/// </summary>
public sealed record MemoryStateSnapshot
{
    /// <summary>
    /// Recent operator usage history (last N bars).
    /// Key: operator ID, Value: usage count in memory window.
    /// </summary>
    public required IReadOnlyDictionary<string, int> RecentOperatorUsage { get; init; }

    /// <summary>
    /// Last fill shape information (if any fill in memory).
    /// </summary>
    public FillShapeSnapshot? LastFillShape { get; init; }

    /// <summary>
    /// Number of bars in the memory window.
    /// </summary>
    public required int MemoryWindowSize { get; init; }
}

/// <summary>
/// Snapshot of fill shape from memory.
/// </summary>
public sealed record FillShapeSnapshot
{
    /// <summary>
    /// Bar number where fill occurred.
    /// </summary>
    public required int BarNumber { get; init; }

    /// <summary>
    /// Roles involved in the fill.
    /// </summary>
    public required IReadOnlyList<string> Roles { get; init; }

    /// <summary>
    /// Density level of the fill (0.0-1.0).
    /// </summary>
    public required double Density { get; init; }

    /// <summary>
    /// Ending beat of the fill.
    /// </summary>
    public required decimal EndingBeat { get; init; }
}

/// <summary>
/// Comparison of density target vs actual density achieved.
/// </summary>
public sealed record DensityComparison
{
    /// <summary>
    /// Target density (0.0-1.0) from policy provider.
    /// </summary>
    public required double TargetDensity { get; init; }

    /// <summary>
    /// Actual density achieved after selection.
    /// </summary>
    public required double ActualDensity { get; init; }

    /// <summary>
    /// Target event count derived from density.
    /// </summary>
    public int? TargetEventCount { get; init; }

    /// <summary>
    /// Actual event count after selection.
    /// </summary>
    public required int ActualEventCount { get; init; }

    /// <summary>
    /// Whether density target was met.
    /// </summary>
    public bool TargetMet => Math.Abs(TargetDensity - ActualDensity) < 0.01;
}

/// <summary>
/// Records a physicality violation that caused candidate filtering.
/// </summary>
public sealed record PhysicalityViolation
{
    /// <summary>
    /// Candidate ID that was rejected.
    /// </summary>
    public required string CandidateId { get; init; }

    /// <summary>
    /// Type of violation (e.g., "LimbConflict", "StickingViolation", "Overcrowding").
    /// </summary>
    public required string ViolationType { get; init; }

    /// <summary>
    /// Detailed reason for violation.
    /// Format: "ViolationType:Detail" (e.g., "LimbConflict:RightHand:Snare+Tom1@1.5")
    /// </summary>
    public required string Reason { get; init; }

    /// <summary>
    /// Whether the candidate was protected (should not have been filtered but was logged).
    /// </summary>
    public bool WasProtected { get; init; }
}
