
GREAT IDEA - tag notes with "favored note" if its in the prior harmony as well as current< maybe first half of time chunk it checks before, 
and last half checks forward harmony notes. Maybe super favored if in both.










Below is a focused explanation of each element and how they work together in the ScoreDesign class.
•	public string DesignId { get; }
•	Purpose: A stable identifier for the design document (used for persistence, correlation, and deduplication).
•	Behavior: Get-only. Set once in the constructor. Defaults to a GUID string in “N” format (32 hex chars, no dashes), ensuring uniqueness unless a custom designId is supplied.

•	public string? SourcePath { get; init; }
•	Purpose: The file path of the score this design decorates (e.g., the MusicXML file).
•	Nullability: Optional; may be null if unknown or not persisted.
•	Mutability: init-only, so it can be set in the constructor or via object initializer at creation time, but not modified afterward.

•	public string? SourceHash { get; init; }
•	Purpose: A content hash (e.g., SHA-256) of the source score used to detect drift (design no longer matches the exact file content).
•	Nullability and mutability: Same as SourcePath (init-only, optional).

•	private readonly List<Section> _sections = new();
•	Purpose: Backing store for sections (Intro, Verse, Chorus, etc.), each representing a named musical span.
•	readonly ensures the field reference cannot be reassigned after construction; the list’s contents can still be modified internally.

•	private readonly List<Annotation> _annotations = new();
•	Purpose: Backing store for annotations (e.g., ChordAnnotation, rhythm, texture) that describe intent over ranges/scopes.
•	Same mutability pattern as _sections.

•	private readonly Dictionary<string, string> _metadata = new(StringComparer.OrdinalIgnoreCase);
•	Purpose: Arbitrary key/value metadata (e.g., author, version, tooling info).
•	Case-insensitive keys (OrdinalIgnoreCase) avoid duplicate entries that differ only by case.

•	public IReadOnlyList<Section> Sections => _sections;
•	Purpose: Read-only view of sections for consumers.
•	Notes: Exposes the list as read-only (cannot add/remove externally). Internally, the class can still modify _sections. Changes are reflected in this view (it’s not a copy).

•	public IReadOnlyList<Annotation> Annotations => _annotations;
•	Purpose: Read-only view of annotations with the same characteristics as Sections.

•	public IReadOnlyDictionary<string, string> Metadata => _metadata;
•	Purpose: Read-only view of metadata with the same characteristics as above.

•	public Design(string? sourcePath = null, string? sourceHash = null, string? designId = null)
•	Responsibility: Initializes identity and optional source linkage.
•	Behavior:

•	DesignId: Uses provided designId or generates a new GUID string (Guid.NewGuid().ToString("N")).

•	SourcePath/SourceHash: Captured from parameters; can be overridden via object initializer due to init setters.
•	Defaults enable creation even when the source isn’t known up-front.

How this all fits together
•	Identity: DesignId uniquely identifies a design document independent of the score file.
•	Source correlation: SourcePath and SourceHash let you bind the design to a specific score instance and detect when the underlying score changes.
•	Controlled mutability: Internal collections (_sections, _annotations, _metadata) are mutable only inside the class, while consumers get read-only views. This enforces encapsulation and prevents accidental external mutation.
•	Extensibility: Sections and annotations can grow in number and variety without changing the public surface (consumers enumerate the read-only lists; creation is done via methods like AddSection/AddAnnotation elsewhere in the class).
•	Safety and clarity: Case-insensitive metadata avoids key collisions; init-only properties allow safe one-time configuration at construction.
Net effect: This snippet defines the identity and source linkage for a design document and exposes immutable views over internally managed collections that describe the musical design layered on top of the score.

==============================================================================================

Chat history

You said:
explain these musical terms list ed in this enum:
  public enum SectionType
  {
      Intro,
      Verse,
      Refrain,
      Chorus,
      Bridge,
      Ending,
      Outro,
      Custom
  }
ChatGPT said:

Thought for 5s
Here’s what each label usually means in song structure—straight, no fluff:

Intro
The opening. Sets key, tempo, groove, and vibe before the vocals/main hook. Often 1–8 bars. Can be a stripped-down version of the verse/chorus chord loop or a unique lead-in.

Verse
Story/detail section. Same music repeats with new lyrics each time. Lower intensity than the chorus; builds tension and context that the chorus resolves.

Refrain
A short, repeating lyric line (often the hook) that returns at the end of each verse. In some traditions, the “refrain” is just a one- or two-line payoff, not a full separate section.
Key point: refrain ≠ chorus. A chorus is a full repeated section; a refrain is a repeated line/track, often embedded in the verse.

Chorus
The main payoff. Highest energy, clearest hook, repeated lyrics and melody each time. Typically broader than a refrain—8+ bars with its own chord loop/arrangement lift.

Bridge
A contrast section (aka “middle eight”). New chords, melody, or perspective to break verse/chorus repetition. Usually appears once after the second chorus, then returns to a final chorus.

Ending
The termination event. Could be a hard “button” (full-band hit), a tag (repeating the last line a few times), a ritard, or a written coda. It’s about how it stops.

Outro
The tail section leading to the end—like an “exit” version of the intro. Might vamp on the chorus chords, solo out, or fade. The outro can contain the ending; the ending is the moment it actually ends.

Custom
Catch-all for anything else: pre-chorus (climb), post-chorus (drop-in hook), instrumental solo, breakdown, interlude, vamp, coda, ad lib, etc. Use this when the section doesn’t cleanly fit the above.

Quick distinctions that trip people up
Refrain vs Chorus: refrain = short recurring line; chorus = full repeating section/hook. Some genres use “refrain” to mean “chorus,” but strictly they’re different.

Ending vs Outro: outro is the run-out; ending is the actual stop (or fade). You can have an outro without a special ending (e.g., a fade), or a button ending with no real “outro” build.

Typical placement
Intro → Verse → (Pre-Chorus)* → Chorus → Verse → (Pre-Chorus)* → Chorus → Bridge → Chorus (×1–2) → Outro/Ending
(*Pre-chorus would be one of those “Custom” cases in your enum.)

tom petty file
========================================================================================

Based on my analysis of the Tom Petty "Breakdown" MIDI file and the MidiEvent model class, here are the MIDI events found in the file and their support status:
✅ FULLY SUPPORTED EVENTS (Found in the file)
1.	NoteOn (0x9n) - Extensively used throughout all tracks
2.	NoteOff (0x8n) - Used throughout all tracks
3.	ProgramChange (0xCn) - Found in tracks (setting instruments)
4.	ControlChange (0xBn) - Present in multiple tracks
5.	SetTempo (0x51) - Found at the beginning
6.	TimeSignature (0x58) - Found at the beginning
7.	EndOfTrack (0x2F) - Present at the end of each track
8.	SequenceTrackName (0x03) - Found in each track (PIANO, GUITAR 1, GUITAR 2, GUITAR 3, ORGAN, BASS, DRUMS, PERC EFFECTS)
❌ UNSUPPORTED/POTENTIALLY MISSING EVENTS
Based on the MIDI file structure, here are events that might be present but are NOT explicitly handled by your MidiEvent model:
Channel Events:
1.	Running Status - MIDI optimization where status bytes are omitted for consecutive events of the same type on the same channel. Your converter needs to handle this implicitly (DryWetMidi library handles this).
Meta Events:
2.	SequenceNumber (0x00) - Not in your model
3.	MIDI Channel Prefix (0x20) - Not in your model
4.	MIDI Port (0x21) - Not in your model
5.	CuePoint (0x07) - Not in your model
6.	DeviceName (0x09) - Not in your model
7.	UnknownMeta - Generic catch-all for unrecognized meta events
System Exclusive (SysEx) Events:
8.	NormalSysExEvent (0xF0) - Not in your model
9.	EscapeSysExEvent (0xF7) - Not in your model
System Common/Real-Time:
10.	MTC Quarter Frame (0xF1) - Not in your model
11.	SongPositionPointer (0xF2) - Not in your model
12.	SongSelect (0xF3) - Not in your model
13.	TuneRequest (0xF6) - Not in your model
14.	TimingClock (0xF8) - Not in your model
15.	Start (0xFA) - Not in your model
16.	Continue (0xFB) - Not in your model
17.	Stop (0xFC) - Not in your model
18.	ActiveSensing (0xFE) - Not in your model
19.	Reset (0xFF) - Not in your model (Note: 0xFF is also meta event marker)
📊 SPECIFIC ANALYSIS OF TOM PETTY FILE
Looking at the raw MIDI data visible in the file context:
1.	Track 0 (Header track):
•	Contains tempo (SetTempo) ✅
•	Contains time signature (TimeSignature) ✅
•	Track name ✅
2.	Tracks 1-8 (Instrument tracks):
•	Heavy use of NoteOn/NoteOff ✅
•	ProgramChange for instrument selection ✅
•	ControlChange events ✅
•	Track names ✅
3.	Potential Issues:
•	The hex data shows extensive use of MIDI velocity values and complex timing
•	Some control changes might be for:
•	Volume (CC 7) ✅ Supported via ControlChange
•	Pan (CC 10) ✅ Supported via ControlChange
•	Sustain Pedal (CC 64) ✅ Supported via ControlChange
•	Bank Select (CC 0/32) ✅ Supported via ControlChange
🎯 RECOMMENDATION
Your current MidiEvent model should handle the Tom Petty "Breakdown" MIDI file successfully because:
1.	All the core events used in typical MIDI files (NoteOn, NoteOff, ProgramChange, ControlChange, SetTempo, TimeSignature, SequenceTrackName) are supported
2.	The DryWetMidi library will handle the low-level parsing
3.	Any unsupported events will trigger your NotSupportedException with detailed error messages
To test this, simply try importing the file using your current implementation. If any unsupported events are encountered, your error handling will show you exactly what needs to be added with this format:




